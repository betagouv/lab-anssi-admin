#!/usr/bin/env bash_unit

setup() {
  setup_backup_script

  S3_FAKE_DIR="$(mktemp -d)" ; export S3_FAKE_DIR
  FAKE_S3_URL=s3:__${BACKUP_BUCKET_NAME}_backups_
  TMP_DIR="$(mktemp -d)" ; export TMP_DIR

  fake pgdump cat fixtures/my_database.dump

  fake s3_push _push
}

setup_backup_script() {

  export CLEVER_SECRET=mandatory
  export CLEVER_TOKEN=mandatory
  export S3_HOST_BUCKET=mandatory

  GPG_HOME_DIR="$(mktemp -d)" ; export GPG_HOME_DIR

  PGP_KEYS="$(cat fixtures/toto.public_key.asc fixtures/titi.public_key.asc)" ; export PGP_KEYS
  export ADDON_ID_my_database=addon_bdc1e3d1-190e-4a5e-a694-e8da77c1a92e
  export ADDON_ID_my_other_database=addon_bdc2e4d2-190e-4a6e-a695-e9da79c2a93e
  export BACKUP_BUCKET_NAME=fake_bucket
}

teardown() {
  rm -rf "${S3_FAKE_DIR}"
  rm -rf "${GPG_HOME_DIR}"
  rm -rf "${TMP_DIR}"
}

test_can_backup_several_databases() {
  assert ../backup

  local s3_destination="${S3_FAKE_DIR}/${FAKE_S3_URL}"

  assert "test -f ${s3_destination}my_database.pgp" "$(ls "${s3_destination}"*)"
  assert "test -f ${s3_destination}my_other_database.pgp"
}

test_toto_can_decipher_backup_key() {
  ../backup > "$TMP_DIR/backup_key" 2>/dev/null

  import_private_key toto

  assert "gpg --homedir ${GPG_HOME_DIR} --decrypt $TMP_DIR/backup_key" "toto is unable to decrypt the key used to cipher the backups: $(cat "$TMP_DIR/backup_key")"
}

test_titi_can_decipher_the_backup_key_and_then_the_backup() {
  ../backup > "$TMP_DIR/backup_key" 2>/dev/null

  import_private_key titi

  local backup_key
  backup_key="$(gpg --homedir "${GPG_HOME_DIR}" --decrypt "$TMP_DIR/backup_key" 2>/dev/null)"

  local expected_archive_path="${S3_FAKE_DIR}/${FAKE_S3_URL}my_database.pgp"
  assert "gpg --homedir ${GPG_HOME_DIR} --decrypt --passphrase ${backup_key} --batch ${expected_archive_path}" "pgp encrypted archive not created: ${expected_archive_path}"
}

test_titi_can_decipher_the_backup_key_and_then_the_backup_and_it_matches_the_expected_backup() {
  ../backup > "$TMP_DIR/backup_key" 2>/dev/null

  import_private_key titi

  local backup_key
  backup_key="$(gpg --homedir "${GPG_HOME_DIR}" --decrypt "$TMP_DIR/backup_key" 2>/dev/null)"

  local expected_archive_path="${S3_FAKE_DIR}/${FAKE_S3_URL}my_database.pgp"
  gpg --homedir "${GPG_HOME_DIR}" --decrypt --passphrase "${backup_key}" --batch "${expected_archive_path}" > "$TMP_DIR/my_database.dump" 2>/dev/null

  assert_no_diff "$TMP_DIR/my_database.dump" fixtures/my_database.dump "the backup does not match the expected backup"
}

test_fails_when_no_backup_to_perform() {
  for var in $(set | grep '^ADDON_ID')
  do
    var_name="$(echo "$var" | cut -d= -f1)"
    unset "${var_name}"
  done

  assert_fail ../backup
}

_push() {
  cat > "${S3_FAKE_DIR}/$(echo "${FAKE_PARAMS[0]}" | tr / _)"
} 
export -f _push

import_private_key() {
  local admin="$1"
  gpg --homedir "${GPG_HOME_DIR}" --import "fixtures/${admin}.private_key.asc" 2>/dev/null
}

# vim: syntax=sh
